# Task ID: 7
# Title: 게임 결과 화면 및 애니메이션 구현
# Status: pending
# Dependencies: 5, 6
# Priority: medium
# Description: 게임 승리 또는 패배 시 결과를 시각적으로 표시하고, 간단한 애니메이션 효과를 추가한다.
# Details:
1. 게임 결과 표시 CSS 추가 (styles.css):
```css
@keyframes reveal {
  0% { transform: scale(0.1); opacity: 0; }
  50% { transform: scale(1.2); opacity: 0.5; }
  100% { transform: scale(1); opacity: 1; }
}

@keyframes shake {
  0%, 100% { transform: translateX(0); }
  10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
  20%, 40%, 60%, 80% { transform: translateX(5px); }
}

.cell.mine-exploded {
  background-color: red !important;
  animation: shake 0.5s;
}

.cell.revealed {
  animation: reveal 0.2s;
}

.game-result {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background-color: rgba(0, 0, 0, 0.8);
  color: white;
  padding: 20px;
  border-radius: 10px;
  text-align: center;
  z-index: 100;
}

.game-result h2 {
  margin-top: 0;
}

.game-result button {
  margin-top: 15px;
  padding: 8px 15px;
  background-color: #4CAF50;
  border: none;
  color: white;
  cursor: pointer;
  border-radius: 4px;
}

.game-result button:hover {
  background-color: #45a049;
}

.game-result .stats {
  margin: 15px 0;
  font-size: 18px;
}
```

2. 게임 결과 표시 함수 추가 (game.js):
```javascript
// 게임 결과 표시 함수
function showGameResult(isWin) {
  const resultElement = document.createElement('div');
  resultElement.className = 'game-result';
  
  if (isWin) {
    resultElement.innerHTML = `
      <h2>축하합니다! 승리했습니다!</h2>
      <div class="stats">
        <div>소요 시간: ${game.timer}초</div>
        <div>난이도: ${getDifficultyName()}</div>
      </div>
      <button id="play-again">다시 플레이</button>
    `;
  } else {
    resultElement.innerHTML = `
      <h2>게임 오버!</h2>
      <div class="stats">
        <div>소요 시간: ${game.timer}초</div>
        <div>난이도: ${getDifficultyName()}</div>
      </div>
      <button id="try-again">다시 시도</button>
    `;
  }
  
  document.body.appendChild(resultElement);
  
  // 다시 플레이 버튼 이벤트 리스너
  document.getElementById(isWin ? 'play-again' : 'try-again').addEventListener('click', () => {
    document.body.removeChild(resultElement);
    game.reset();
    renderBoard();
    document.getElementById('restart-btn').textContent = '😊';
  });
}

// 현재 난이도 이름 반환 함수
function getDifficultyName() {
  const { rows, cols, mines } = game;
  
  if (rows === DIFFICULTY.BEGINNER.rows && cols === DIFFICULTY.BEGINNER.cols && mines === DIFFICULTY.BEGINNER.mines) {
    return '초급';
  } else if (rows === DIFFICULTY.INTERMEDIATE.rows && cols === DIFFICULTY.INTERMEDIATE.cols && mines === DIFFICULTY.INTERMEDIATE.mines) {
    return '중급';
  } else if (rows === DIFFICULTY.EXPERT.rows && cols === DIFFICULTY.EXPERT.cols && mines === DIFFICULTY.EXPERT.mines) {
    return '고급';
  } else {
    return '사용자 정의';
  }
}

// revealCell 메서드 수정 - 게임 결과 표시 추가
function handleCellClick(event) {
  // 기존 코드 유지...
  
  const result = game.revealCell(row, col);
  updateBoard();
  
  if (result === 'gameover') {
    // 클릭한 지뢰 셀에 특별한 스타일 적용
    cell.classList.add('mine-exploded');
    document.getElementById('restart-btn').textContent = '😵';
    
    // 약간의 지연 후 결과 화면 표시
    setTimeout(() => {
      showGameResult(false);
    }, 1000);
  } else if (result === 'win') {
    document.getElementById('restart-btn').textContent = '😎';
    
    // 약간의 지연 후 결과 화면 표시
    setTimeout(() => {
      showGameResult(true);
    }, 1000);
  }
}
```

3. 애니메이션 효과를 위한 updateBoard 함수 수정:
```javascript
function updateBoard() {
  const boardElement = document.getElementById('game-board');
  const cells = boardElement.querySelectorAll('.cell');
  
  for (let row = 0; row < game.rows; row++) {
    for (let col = 0; col < game.cols; col++) {
      const index = row * game.cols + col;
      const cell = cells[index];
      const cellData = game.board[row][col];
      
      // 이전 상태 저장
      const wasRevealed = cell.classList.contains('revealed');
      
      // 셀 상태에 따라 UI 업데이트
      if (cellData.isRevealed) {
        // 새로 열린 셀에만 애니메이션 적용
        if (!wasRevealed) {
          cell.classList.add('revealed');
        }
        
        if (cellData.isMine) {
          cell.textContent = '💣';
          cell.style.backgroundColor = '#ffcccc';
        } else if (cellData.neighborMines > 0) {
          cell.textContent = cellData.neighborMines;
          // 숫자에 따라 색상 지정
          const colors = ['blue', 'green', 'red', 'purple', 'maroon', 'turquoise', 'black', 'gray'];
          cell.style.color = colors[cellData.neighborMines - 1];
        }
      } else if (cellData.isFlagged) {
        cell.textContent = '🚩';
      } else {
        cell.textContent = '';
        cell.className = 'cell';
        cell.style.color = '';
        cell.style.backgroundColor = '';
      }
    }
  }
}
```

# Test Strategy:
1. 게임 승리 시 승리 화면이 정상적으로 표시되는지 확인
2. 게임 패배 시 패배 화면이 정상적으로 표시되는지 확인
3. 결과 화면에 소요 시간과 난이도가 정확히 표시되는지 확인
4. '다시 플레이' 버튼 클릭 시 게임이 정상적으로 재시작되는지 확인
5. 셀 오픈 애니메이션이 자연스럽게 작동하는지 확인
6. 지뢰 폭발 애니메이션이 정상적으로 표시되는지 확인

# Subtasks:
## 1. 게임 결과 화면 컴포넌트 구현 [pending]
### Dependencies: None
### Description: 승리 또는 패배 시 표시될 결과 화면 컴포넌트를 구현합니다. 결과 화면에는 게임 결과(승리/패배), 소요 시간, 난이도 정보와 재시작 버튼이 포함됩니다.
### Details:
1. showGameResult 함수를 구현합니다:
- 매개변수로 isWin(boolean)을 받아 승리/패배 여부 확인
- 결과 화면 DOM 요소 생성 및 스타일 적용
- 게임 통계(소요 시간, 난이도) 표시
- 재시작 버튼 추가
2. getDifficultyName 함수를 구현하여 현재 게임 난이도 이름을 반환합니다.
3. 재시작 버튼에 이벤트 리스너를 추가하여 게임을 초기화하고 결과 화면을 제거합니다.

## 2. 셀 애니메이션 효과 구현 [pending]
### Dependencies: None
### Description: 게임 보드의 셀에 애니메이션 효과를 추가합니다. 셀이 열릴 때와 지뢰가 폭발할 때 각각 다른 애니메이션을 적용합니다.
### Details:
1. CSS에 애니메이션 키프레임 정의:
- reveal 애니메이션: 셀이 열릴 때 확대되며 나타나는 효과
- shake 애니메이션: 지뢰가 폭발할 때 흔들리는 효과
2. 관련 CSS 클래스 구현:
- .cell.mine-exploded: 폭발한 지뢰 셀 스타일 및 애니메이션
- .cell.revealed: 열린 셀 애니메이션
3. updateBoard 함수에서 새로 열린 셀에만 애니메이션 적용하도록 로직 추가

## 3. 게임 결과 감지 및 처리 로직 구현 [pending]
### Dependencies: 7.1, 7.2
### Description: 게임의 승리 또는 패배 조건을 감지하고, 해당 이벤트 발생 시 적절한 결과 화면과 애니메이션을 표시하는 로직을 구현합니다.
### Details:
1. handleCellClick 함수를 수정하여 게임 결과 처리:
- revealCell 메서드의 반환값('gameover', 'win', 또는 undefined)에 따라 처리
- 게임 오버 시: 클릭한 지뢰 셀에 'mine-exploded' 클래스 추가, 이모티콘 변경(😵)
- 승리 시: 이모티콘 변경(😎)
2. setTimeout을 사용하여 애니메이션 완료 후 결과 화면 표시(약 1초 지연)
3. 게임 상태에 따라 적절한 showGameResult 함수 호출

## 4. 셀 상태 시각화 개선 [pending]
### Dependencies: 7.2
### Description: 게임 보드의 셀 상태(열림, 깃발, 지뢰 등)에 따라 시각적 표현을 개선하고, 숫자에 따른 색상 코드를 구현합니다.
### Details:
1. updateBoard 함수를 수정하여 셀 상태에 따른 시각화 개선:
- 열린 셀: 'revealed' 클래스 추가 및 애니메이션 적용
- 지뢰 셀: 💣 이모티콘 표시 및 배경색 변경(#ffcccc)
- 숫자 셀: 주변 지뢰 수에 따라 다른 색상 적용
  - 색상 배열: ['blue', 'green', 'red', 'purple', 'maroon', 'turquoise', 'black', 'gray']
- 깃발 셀: 🚩 이모티콘 표시
2. 이전 상태와 비교하여 새로 열린 셀에만 애니메이션 적용하는 로직 구현

## 5. 게임 재시작 및 상태 초기화 기능 구현 [pending]
### Dependencies: 7.1, 7.3
### Description: 게임 결과 화면에서 재시작 버튼 클릭 시 게임을 초기화하고 새 게임을 시작하는 기능을 구현합니다.
### Details:
1. 게임 결과 화면의 재시작 버튼에 이벤트 리스너 추가:
- 결과 화면 DOM 요소 제거
- game.reset() 호출하여 게임 상태 초기화
- renderBoard() 호출하여 게임 보드 다시 그리기
- 재시작 버튼 이모티콘 초기화(😊)
2. 게임 난이도 유지하면서 재시작하는 로직 구현
3. 타이머 및 지뢰 카운터 초기화 로직 추가
4. 게임 재시작 시 모든 애니메이션 상태 초기화

