# Task ID: 4
# Title: 셀 클릭 이벤트 및 게임 로직 구현
# Status: pending
# Dependencies: 3
# Priority: high
# Description: 좌클릭으로 셀을 열고, 우클릭으로 깃발을 표시하는 기능과 빈 셀 클릭 시 재귀적으로 주변 셀을 열어주는 로직을 구현한다.
# Details:
1. MinesweeperGame 클래스에 셀 클릭 관련 메서드 추가:
```javascript
class MinesweeperGame {
  // 기존 코드 유지...
  
  // 셀 클릭 처리
  revealCell(row, col) {
    // 이미 게임이 끝났거나, 이미 열린 셀이거나, 깃발이 꽂힌 셀이면 무시
    if (this.gameOver || this.board[row][col].isRevealed || this.board[row][col].isFlagged) {
      return;
    }
    
    // 첫 클릭인 경우 지뢰 배치
    if (this.firstClick) {
      this.placeMines(row, col);
    }
    
    // 지뢰를 클릭한 경우
    if (this.board[row][col].isMine) {
      this.gameOver = true;
      this.revealAllMines();
      return 'gameover';
    }
    
    // 셀 오픈
    this.board[row][col].isRevealed = true;
    this.revealed++;
    
    // 주변 지뢰가 없는 빈 셀인 경우 재귀적으로 주변 셀 오픈
    if (this.board[row][col].neighborMines === 0) {
      this.revealEmptyCells(row, col);
    }
    
    // 승리 조건 체크: 지뢰가 아닌 모든 셀이 열렸는지
    if (this.revealed === (this.rows * this.cols - this.mineCount)) {
      this.gameOver = true;
      return 'win';
    }
    
    return 'continue';
  }
  
  // 빈 셀 주변을 재귀적으로 열기
  revealEmptyCells(row, col) {
    for (let r = Math.max(0, row - 1); r <= Math.min(this.rows - 1, row + 1); r++) {
      for (let c = Math.max(0, col - 1); c <= Math.min(this.cols - 1, col + 1); c++) {
        // 이미 열린 셀이거나 깃발이 꽂힌 셀은 무시
        if (this.board[r][c].isRevealed || this.board[r][c].isFlagged) {
          continue;
        }
        
        // 셀 오픈
        this.board[r][c].isRevealed = true;
        this.revealed++;
        
        // 빈 셀이면 재귀 호출
        if (this.board[r][c].neighborMines === 0) {
          this.revealEmptyCells(r, c);
        }
      }
    }
  }
  
  // 깃발 토글
  toggleFlag(row, col) {
    // 이미 열린 셀이거나 게임이 끝난 경우 무시
    if (this.board[row][col].isRevealed || this.gameOver) {
      return;
    }
    
    if (this.board[row][col].isFlagged) {
      this.board[row][col].isFlagged = false;
      this.flagCount--;
    } else {
      this.board[row][col].isFlagged = true;
      this.flagCount++;
    }
    
    return this.flagCount;
  }
  
  // 모든 지뢰 보여주기 (게임 오버 시)
  revealAllMines() {
    for (let row = 0; row < this.rows; row++) {
      for (let col = 0; col < this.cols; col++) {
        if (this.board[row][col].isMine) {
          this.board[row][col].isRevealed = true;
        }
      }
    }
  }
}
```

2. 이벤트 핸들러 추가:
```javascript
function handleCellClick(event) {
  const cell = event.target;
  if (!cell.classList.contains('cell')) return;
  
  const row = parseInt(cell.dataset.row);
  const col = parseInt(cell.dataset.col);
  
  const result = game.revealCell(row, col);
  updateBoard();
  
  if (result === 'gameover') {
    alert('게임 오버! 지뢰를 밟았습니다.');
    document.getElementById('restart-btn').textContent = '😵';
  } else if (result === 'win') {
    alert('축하합니다! 모든 지뢰를 찾았습니다!');
    document.getElementById('restart-btn').textContent = '😎';
  }
}

function handleCellRightClick(event) {
  event.preventDefault(); // 컨텍스트 메뉴 방지
  
  const cell = event.target;
  if (!cell.classList.contains('cell')) return;
  
  const row = parseInt(cell.dataset.row);
  const col = parseInt(cell.dataset.col);
  
  const flagCount = game.toggleFlag(row, col);
  updateBoard();
  
  // 남은 지뢰 수 업데이트
  document.querySelector('.mine-counter').textContent = game.mineCount - flagCount;
}

function updateBoard() {
  const boardElement = document.getElementById('game-board');
  const cells = boardElement.querySelectorAll('.cell');
  
  for (let row = 0; row < game.rows; row++) {
    for (let col = 0; col < game.cols; col++) {
      const index = row * game.cols + col;
      const cell = cells[index];
      const cellData = game.board[row][col];
      
      // 셀 상태에 따라 UI 업데이트
      if (cellData.isRevealed) {
        cell.classList.add('revealed');
        
        if (cellData.isMine) {
          cell.textContent = '💣';
          cell.style.backgroundColor = 'red';
        } else if (cellData.neighborMines > 0) {
          cell.textContent = cellData.neighborMines;
          // 숫자에 따라 색상 지정
          const colors = ['blue', 'green', 'red', 'purple', 'maroon', 'turquoise', 'black', 'gray'];
          cell.style.color = colors[cellData.neighborMines - 1];
        }
      } else if (cellData.isFlagged) {
        cell.textContent = '🚩';
      } else {
        cell.textContent = '';
        cell.className = 'cell';
      }
    }
  }
}

// 이벤트 리스너 등록
document.addEventListener('DOMContentLoaded', () => {
  renderBoard();
  
  const boardElement = document.getElementById('game-board');
  boardElement.addEventListener('click', handleCellClick);
  boardElement.addEventListener('contextmenu', handleCellRightClick);
});
```

# Test Strategy:
1. 좌클릭으로 셀이 정상적으로 열리는지 확인
2. 우클릭으로 깃발이 정상적으로 표시/제거되는지 확인
3. 빈 셀 클릭 시 주변 셀이 재귀적으로 열리는지 확인
4. 지뢰 클릭 시 게임 오버가 정상적으로 처리되는지 확인
5. 모든 안전한 셀을 열었을 때 승리 조건이 정상적으로 처리되는지 확인
6. 첫 클릭에서 지뢰를 밟지 않는지 확인

# Subtasks:
## 1. 구현된 MinesweeperGame 클래스 메서드 테스트 [pending]
### Dependencies: None
### Description: MinesweeperGame 클래스의 revealCell, revealEmptyCells, toggleFlag, revealAllMines 메서드가 올바르게 작동하는지 테스트한다.
### Details:
1. 각 메서드를 개별적으로 테스트하는 함수 작성
2. revealCell 메서드 테스트: 첫 클릭 시 지뢰 배치, 지뢰 클릭 시 게임오버, 빈 셀 클릭 시 주변 셀 오픈, 승리 조건 확인
3. revealEmptyCells 메서드 테스트: 빈 셀 주변이 올바르게 열리는지 확인
4. toggleFlag 메서드 테스트: 깃발 토글 기능 및 카운터 업데이트 확인
5. revealAllMines 메서드 테스트: 게임 오버 시 모든 지뢰가 표시되는지 확인
6. 콘솔에 테스트 결과 출력

## 2. 셀 클릭 이벤트 핸들러 구현 [pending]
### Dependencies: None
### Description: 좌클릭으로 셀을 열고 게임 상태를 업데이트하는 이벤트 핸들러를 구현한다.
### Details:
1. handleCellClick 함수 구현
2. 클릭된 셀의 row, col 데이터 추출
3. game.revealCell(row, col) 호출하여 게임 로직 실행
4. 반환된 결과(continue, gameover, win)에 따라 적절한 처리
5. 게임 오버 시 알림 표시 및 이모티콘 변경
6. 승리 시 축하 메시지 표시 및 이모티콘 변경
7. updateBoard 함수 호출하여 UI 업데이트

## 3. 우클릭 깃발 표시 기능 구현 [pending]
### Dependencies: None
### Description: 우클릭으로 셀에 깃발을 표시하거나 제거하는 기능을 구현한다.
### Details:
1. handleCellRightClick 함수 구현
2. event.preventDefault()로 기본 컨텍스트 메뉴 방지
3. 클릭된 셀의 row, col 데이터 추출
4. game.toggleFlag(row, col) 호출하여 깃발 토글
5. 반환된 깃발 개수를 사용하여 남은 지뢰 수 카운터 업데이트
6. updateBoard 함수 호출하여 UI 업데이트

## 4. 게임 보드 UI 업데이트 함수 구현 [pending]
### Dependencies: None
### Description: 게임 상태에 따라 보드 UI를 업데이트하는 함수를 구현한다.
### Details:
1. updateBoard 함수 구현
2. 게임 보드의 모든 셀을 순회
3. 각 셀의 상태(isRevealed, isFlagged, isMine, neighborMines)에 따라 UI 업데이트
4. 열린 셀에 'revealed' 클래스 추가
5. 지뢰 셀은 💣 이모티콘 표시 및 배경색 변경
6. 숫자 셀은 주변 지뢰 개수 표시 및 숫자별 색상 적용
7. 깃발이 표시된 셀은 🚩 이모티콘 표시
8. 닫힌 셀은 기본 스타일 유지

## 5. 이벤트 리스너 등록 및 통합 테스트 [pending]
### Dependencies: None
### Description: DOM이 로드된 후 이벤트 리스너를 등록하고 전체 게임 기능을 통합 테스트한다.
### Details:
1. DOMContentLoaded 이벤트에 대한 리스너 구현
2. renderBoard 함수 호출하여 초기 게임 보드 렌더링
3. 게임 보드 요소에 클릭 이벤트 리스너 등록(handleCellClick)
4. 게임 보드 요소에 컨텍스트 메뉴 이벤트 리스너 등록(handleCellRightClick)
5. 재시작 버튼에 클릭 이벤트 리스너 등록
6. 전체 게임 플레이 흐름 테스트: 셀 열기, 깃발 표시, 빈 셀 클릭 시 재귀적 오픈, 게임 오버, 승리 조건 등

